//	USBDelay v.0.0.1		- устройство задержки подачи питания (для USB порта)
//	ushanovsn@gmail.com


/*	По умолчанию тинька13 работает на частоте 1,2 МГц
	т.е. частота равна 9,6МГц (CKSEL = 10),
	задержка запуска максимальная (SUT = 10),
	делитель на 8 включен (CLKDIV8)
*/

/* Подключение:
	pin 3 => PB4	- тактовая кнопка
	pin 5 => PB0	- база мосфета
	pin 7 => PB2	- светодиод
*/	



#include <avr/io.h>
#include <avr/interrupt.h>


#define K_TIK_SEK 50	//коэффициент пересчета "тиков" таймера в секунды
#define TIM_COMPARE 3	// значение, для подсчета времени по 20 мсек (таймер "тикает" со скоростью ~0,0066666 сек)
#define EE_TIME_ADDR 1		// адрес хранения времени задержки в EEPROM
#define EE_INVTIME_ADDR 3	// адрес хранения инвертированного значения времени задержки в EEPROM


// *****************************************************************************************************************************************************************************************
// ************  Глобальные переменные и константы  ****************************************************************************************************************************************

uint8_t flags;	// байт с флагами состояний
// 0b00000000
//   -------0	-0 бит: состояние нажатия кнопки (после обработки и подавления дребезга)
//   ------0-	-1 бит: флаг включения/отключения питания USB
//   -----0--	-2 бит:
//   ----0---	-3 бит: флаг включения/отключения светодиода


unsigned char timTik;	// здесь подсчитываются срабатывания таймера
unsigned long mSeconds;	// здесь таймером подсчитываются каждые 20 миллисекунд (сюда можно считать несколько месяцев непрерывно)
unsigned char state;	// здесь будет текущее состояние системы
unsigned long tikBtnSave;	// складываем счетчик таймера (mSeconds) для фильтрации дребезга сигналов кнопки
unsigned long timeBtnPrsd;	// складываем счетчик таймера (в секундах) для подсчета времени удержания нажатия кнопки
uint8_t delayTime;		// время задержки включения




// *****************************************************************************************************************************************************************************************
// ************   Функция инициализации таймера   ******************************************************************************************************************************************
void timerInit (void)
{
	// включаем таймер (по умолчанию таймеры отключены) в режим сравнения с регистром OCR0A
	TIMSK0 |=(1<<OCIE0A);
	
	// установив флаг в регистре TCCR0A в позицию номер WGM01 -  таймер будет в режим совпадения указанного значения
	TCCR0A |= (1<<WGM01);
	
	// устанавливаем делитель для таймера, равный 64, т.е. 1,2МГц/64 = 18750 Гц - итоговая частота генератора таймера
	TCCR0B |= (1<<CS00) | (1<<CS01);
	
	// сбрасываем регистры COM01 и COM00 для того чтобы таймер не переключал пин OC0A
	TCCR0A &= ~((1<<COM0A1) | (1<<COM0A0));
	
	// значение для сравнения таймера.
	// Частота таймера 18750Гц, и при значении сравнения = 125 - таймер будет срабатывать 150 раз в 1 секунду (т.е. один "тик" равен ~0,006666 сек)
	OCR0A = 125;
	
	// Инициализация переменных
	timTik = 0;
	mSeconds = 0;
}









// *****************************************************************************************************************************************************************************************
// ************   Функция записи данных в EEPROM  ******************************************************************************************************************************************
void EEPROM_write(int uiAddress, char ucData)
{
	while(EECR & (1<<EEWE)); /*Ждать завершения предыдущей записи*/
	EEAR = uiAddress; /*Проинициализировать регистры*/
	EEDR = ucData;
	EECR |= (1<<EEMWE); /*Установить флаг EEMWE*/
	EECR |= (1<<EEWE); /*Начать запись в EEPROM*/
}

uint8_t EEPROM_read(int uiAddress)
{
	while(EECR & (1<<EEWE)); /*Ждать завершения предыдущей записи*/
	EEAR = uiAddress; /* Проинициализировать регистр адреса*/
	EECR |= (1<<EERE); /*Выполнить чтение*/
	return EEDR;
}

//// Не укаладываюсь в отведенный объем памяти... Пока всё закоменчу
//// Запись Word в EEPROM
//void EEPROMWriteInt(int p_address, int p_value) // принимает 2 параметра, адрес и число 0...65534
//{ // забирает 2 ячейки, так что использовать ячейки 0, 2, 4, 6...
	//char lowByte = ((p_value >> 0) & 0xFF);
	//char highByte = ((p_value >> 8) & 0xFF);
	//EEPROM_write(p_address, lowByte);
	//EEPROM_write(p_address + 1, highByte);
//}
//// Чтение Word из EEPROM
//int EEPROMReadInt(int p_address) //Считывает число в диапазоне 0...65534
//{ // использует 2 ячейки, так что считывает ячейки 0, 2, 4, 6...
	//char lowByte = EEPROM_read(p_address);
	//char highByte = EEPROM_read(p_address + 1);
	//return ((lowByte << 0) & 0xFF) + ((highByte << 8) & 0xFF00);
//}






// *****************************************************************************************************************************************************************************************
// ************   Обработчик прерывания таймера   ******************************************************************************************************************************************
ISR(TIM0_COMPA_vect)
{
	// считаем "тики" таймера
	timTik++;
	
	if (timTik==TIM_COMPARE){
		// считаем уже "время"
		mSeconds++;
		timTik = 0;
	}
}





int main(void)
{
	// ******************  ИНИЦИАЛИЗАЦИЯ ПОРТОВ И ПЕРЕМЕННЫХ ПРОЕКТА  ****************************************************

	DDRB = 0b00000101;		// порт B0 и B2 выходы

	// порт B4 подтягиваем к VCC, поскольку получаем сигнал GND с кнопки, остальные сбрасываем в 0
	// светодиод на B2 загорится от нуля
	// мосфет на B0 закроется, если был открыт, поскольку притянут к минусу
	PORTB = 0b00010000;

	state = 0;		// стартуем в 0 состоянии
	flags = 0b00001000;		// светодиод при старте включен, остальные флаги сброшены




	// ******************   чтение и проверка времени задержки из EEPROM  ************************************************
	// в EEPROM записано 2 числа, одно число - время задержки, второе число - побитовая инверсия
	// сделано для проверки достоверности записанного времени (чтобы не высчитывать чек-сумму - просто побитовая инверсия)
	delayTime = EEPROM_read(EE_TIME_ADDR);

	
	// инвертируем проверочный байт вычитанием из 255, потому что оператор инверсии (~) работает правильно только с int16
	if (delayTime != ((uint8_t)255 - (EEPROM_read(EE_INVTIME_ADDR)))) {	
		// если данные недостоверны, ставим задержку по умолчанию (10 секунд)
		delayTime = 10;
	};


	// разрешаем прерывания (эта штука используется в Atmel Studio) в другой IDE наверное нет.
	sei();


	// инициализация таймера
	timerInit();





	// *******************************************************************************************************************
	// ***************************  ОСНОВНОЙ ЦИКЛ ПРОГРАММЫ  *************************************************************
	// *******************************************************************************************************************
	
	while (1)
	{
		
		// ******************   постоянно проверяем нажатие кнопки  ******************************************************
		if (PINB & (1 << PINB4)) {
			// по умолчанию пин притянут к "плюсу", при нажатии кнопки приходит "gnd"
			tikBtnSave = 0;
			flags &= ~(1<<0);
		}
		else {
			// если кнопка нажата, присваиваем и далее сохраняем текущий счетчик (время нажатия)
			tikBtnSave += ((tikBtnSave==0) * mSeconds);
			// считаем кол-во секунд, с момента нажатия кнопки
			timeBtnPrsd = (mSeconds - tikBtnSave) / K_TIK_SEK;
			// выставляем флаг нажатия если кнопка нажата БОЛЕЕ 40 мсек
			if ((mSeconds - tikBtnSave) > 2) {
				flags |= (1<<0);
			};
		};
		
	
	
	
	
		// ******************   Включение / отключение питания USB  ******************************************************
		if ((flags & (1<<1)) > 0) {
			// пин PB0 устанавливаем в 1 -> питание вкл. (на мосфет подается плюс)
			PORTB |= (1<<0);
		}
		else {
			// пин PB0 сбрасываем в 0 -> питание откл. (мосфет притянут к минусу)
			PORTB &= ~(1<<0);			
		};

	
	
	
	
		
	
	// ******************   Включение / отключение светодиода  **********************************************************

		if ( (flags & (1<<3)) > 0){
			// пин PB2 сбрасываем в 0 -> светодиод включается
			PORTB &= ~(1<<2);
		}
		else{
			// пин PB2 устанавливаем в 1 -> светодиод выключается
			PORTB |= (1<<2);
		};

	
	
	
	
		
		

		
		// машина состояний
		switch (state)
		{
			// ожидание действий и задержка включения
			case 0:
				// ждём полсекунды и гасим стартовый светодиод
				if (mSeconds >= (K_TIK_SEK / 2)){
					flags &= ~(1<<3);
				};
				// ждём нажатия кнопки (гасим светодиод, вдруг нажатие произошло до истечения стартового времени)
				if ((flags&(1<<0)) > 0){
					flags &= ~(1<<3);
					state = 10;
				};
				// ждём истечения времени таймера задержки включения
				if ((mSeconds / K_TIK_SEK) > delayTime) {
					// включаем питание
					flags |= (1<<1);
					// включаем светодиод (если требуется данная индикация - просто раскомментить следующую строку)
					//flags |= (1<<3);
				};
				break;



			// после любого нажатия кнопки переходим сюда
			// если кнопка нажата более 1 сек => это установка нового времени задержки, с последующей записью в EEPROM
			// если это быстрое нажатие ( от 40 мсек до 1 сек) => принудительная перезагрузка питания
			case 10:
				// кнопка отжата =>			
				if ((flags&(1<<0)) == 0) {
					// проверяем быстрое это нажатие или долгое
					if (timeBtnPrsd > 0) {
						// если кнопка была нажата более 1 сек - сохраняем новое время задержки в EEPROM
						state = 50;
					}
					else {
						// если кнопка была нажата менее 1 сек - передергиваем питание
						state = 100;
					};
				};

			
				// моргаем светодиодом каждую целую секунду
				if (((mSeconds - tikBtnSave) % K_TIK_SEK) < 10) {
					// вкл LED
					flags |= (1<<3);
				};
				// гасим светодиод после 200 мсек. (10 отсчетов mSeconds)
				if (((mSeconds - tikBtnSave) % K_TIK_SEK) > 10) {
					// откл LED
					flags &= ~(1<<3);
				};					
				break;
			
			
			


			// запись времени задержки в EEPROM
			case 50:
				// запрещаем прерывания (требуется для работы с EEPROM)
				cli();
			
				// записываем в EEPROM новое время задержки
				EEPROM_write(EE_TIME_ADDR, timeBtnPrsd);
				
				// записываем в EEPROM побитовую инверсию числа времени задержки, вместо чек-суммы
				// (здесь записывается только младший байт, поэтому допустимо применить оператор инверсии (~))
				EEPROM_write(EE_INVTIME_ADDR, ~timeBtnPrsd);
				
				// после записи значения - вычитываем его, дабы быть уверенным, что всё записалось верно
				delayTime = EEPROM_read(EE_TIME_ADDR);

				// инвертируем проверочный байт вычитанием из 255, потому что оператор инверсии (~) работает правильно только с int16
				if (delayTime != ((uint8_t)255 - (EEPROM_read(EE_INVTIME_ADDR)))) {
					// если данные недостоверны, ставим задержку по умолчанию (10 секунд)
					delayTime = 10;
				};
				
				// разрешаем прерывания (запрет требовался для работы с EEPROM)
				sei();
					
				// передергиваем питание с новым временем задержки
				state = 100;
				break;





			// передергиваем питание
			case 100:
				// флаг отключения питания
				flags &= ~(1<<1);
				// флаг включения светодиода
				flags |= (1<<3);
					
				// сбрасываем все таймеры
				timTik = 0;
				mSeconds = 0;
				// далее отсчет задержки включения питания начнется заново
			
				// переходим в режим ожидания
				state = 0;
				break;



			
			
		}	// switch	
	}		// while (true)
}			// main()

